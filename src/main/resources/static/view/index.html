<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PhotoUpp</title>
    <style>
      body {
        font-family: helvetica, arial, sans-serif;
        padding: 0;
        margin: 0;
        background-color: #fffcf2;
        overflow: hidden;
      }

      .photo {
        display: inline-block;
        position: absolute;
        top: 60%;
        left: 50%;
        translate: -50% -50%;
        background: linear-gradient(110deg, white, rgb(245, 245, 245));
        padding: 4vmin;
        box-shadow: 0.5vmin 0.5vmin 1.5vmin rgb(41, 41, 41);
      }
      .photo > img {
        max-height: 50vh;
        max-width: 50vw;
        vertical-align: middle;
      }

      .slideout-from-top {
        animation-duration: 3s;
        animation-name: slideout-from-top;
        animation-fill-mode: forwards;
        animation-timing-function: ease-in;
      }
      @keyframes slideout-from-top {
        to {
          transform: translate(-150vw, 150vh) scale(1.5) rotate(-20deg);
        }
      }

      .slideout {
        animation-delay: 200ms;
        animation-duration: 800ms;
        animation-name: slideout;
        animation-fill-mode: forwards;
        animation-timing-function: ease-in-out;
      }
      @keyframes slideout {
        to {
          transform: translate(150vw, 150vh) scale(1.5);
        }
      }

      .slidein {
        /* we set initial opacity to 0 and delay the animation a bit
        so that we get a first (transparent) rendering, which speeds up the animation */
        opacity: 0;
        animation-delay: 100ms;
        animation-duration: 700ms;
        animation-name: slidein;
        animation-fill-mode: forwards;
        animation-timing-function: ease-in;
      }
      @keyframes slidein {
        from {
          translate: -150vw -50vh;
          scale: 1.5;
          rotate: -10deg;
          opacity: 1;
        }
        to {
          opacity: 1;
        }
      }

      .qr {
        display: inline-block;
        position: absolute;
        right: 1vmin;
        top: 1vmin;
        background-color: white;
        border-radius: 3vmin;
        padding: 3vmin;
        text-align: center;
      }
      .qr img {
        width: 20vmin;
        height: 20vmin;
      }
    </style>
  </head>
  <body>
    <div class="qr">
      <div>Fotos hochladen:</div>
      <img src="qr.svg" />
      <div>https://up.czedik.at</div>
    </div>
    <!--<div class="photo slideout-from-top">
      <img
        src="/api/serve/2023-01-03_22-15-52_IMG_20230103_221550__19324efd682818fbf781665d036cd68be0a18bd31ece89b2bf086dc8d702e791.jpg"
      />
    </div>
    <div class="photo slidein">
      <img
        src="/api/serve/2023-01-29_12-26-04_IMG_20230129_122602__c08ab8004a6db402b9a458a64ea012b1bbddcd1627fe95ec0cb018d5a19c4b20.jpg"
      />
    </div>-->

    <div id="photocontainer"></div>
    <script>
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      const photoContainer = document.querySelector("#photocontainer");

      const numberOfPhotosToShow = 7;

      // all photos
      let photos = new Set();

      // new photos not shown yet
      let newPhotos = [];

      let numberToPreload = 3;
      let photosToPreload = [];

      let shownPhotos = [];

      async function fetchAndUpdatePhotos() {
        let loadedPhotos;
        try {
          const response = await fetch("/api/list", {
            cache: "no-cache",
            // note: no-cache ensures that at least conditional request is always made (but if the content has not changed the response will be empty)
          });
          const jsonData = await response.json();
          loadedPhotos = jsonData.photos;
        } catch (error) {
          console.error(error);
          return;
        }

        if (photos.size > 0) {
          newPhotos.push(...loadedPhotos.filter((p) => !photos.has(p)));
        }
        photos = new Set(loadedPhotos);
      }

      function partition(array, isValid) {
        return array.reduce(
          ([pass, fail], elem) => {
            return isValid(elem)
              ? [[...pass, elem], fail]
              : [pass, [...fail, elem]];
          },
          [[], []]
        );
      }

      function getRandomItem(items) {
        return items[Math.floor(Math.random() * items.length)];
      }

      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min);
      }

      function preloadImage(name, isNew) {
        const img = new Image();
        img.src = "/api/serve/" + encodeURIComponent(name);
        photosToPreload.unshift({
          name,
          img,
          isNew,
        });
      }

      async function init() {
        while (true) {
          await fetchAndUpdatePhotos();

          // TODO just for testing
          //newPhotos = Array.from(photos);

          newPhotos.forEach((name) => preloadImage(name, true));
          newPhotos = [];

          const [completedNew, others] = partition(
            photosToPreload,
            (p) => p.img.complete && p.isNew
          );
          photosToPreload = others;

          const start = Date.now();

          for (const p of completedNew) {
            const photoDiv = document.createElement("div");
            photoDiv.className = "photo slidein";
            photoDiv.appendChild(p.img);
            const rotation = getRandomIntInclusive(-10, 10);
            photoDiv.style.top = "50%";
            photoDiv.style.left = "40%";
            photoDiv.style.transform = `rotate(${rotation}deg)`;
            photoContainer.appendChild(photoDiv);

            let next = true;
            shownPhotos.forEach((p) => {
              p.photoDiv.style.transition = "transform 300ms";
              p.photoDiv.style.transitionDelay = "700ms";
              p.rotation += getRandomIntInclusive(-3, 3);
              p.scale *= 0.8;
              p.shiftTop += 10;
              if (next) {
                p.shiftLeft += 20;
                next = false;
              } else {
                p.shiftLeft += 10;
              }
              p.photoDiv.style.transform = `translate(${p.shiftLeft}vw, ${p.shiftTop}vh) scale(${p.scale}) rotate(${p.rotation}deg)`;
            });

            shownPhotos.unshift({
              name: p.name,
              rotation,
              shiftTop: 0,
              shiftLeft: 0,
              scale: 1,
              photoDiv,
            });

            let removedPhoto = null;
            if (shownPhotos.length > numberOfPhotosToShow) {
              removedPhoto = shownPhotos.pop();
              removedPhoto.photoDiv.classList.remove("slidein");
              removedPhoto.photoDiv.classList.add("slideout");
            }

            await sleep(1000);

            if (removedPhoto != null) {
              photoContainer.removeChild(removedPhoto.photoDiv);
            }
          }

          const numberOfPhotosToPreload =
            numberOfPhotosToShow - shownPhotos.length + 3;

          let extraPhotosToPreload =
            numberOfPhotosToPreload - photosToPreload.length;

          if (extraPhotosToPreload > 0) {
            const preloadingCandidates = new Set(photos);
            photosToPreload
              .map((p) => p.name)
              .forEach((name) => preloadingCandidates.delete(name));
            shownPhotos
              .map((p) => p.name)
              .forEach((name) => preloadingCandidates.delete(name));

            extraPhotosToPreload = Math.min(
              extraPhotosToPreload,
              preloadingCandidates.size
            );

            const toPreload = [];
            for (let i = 0; i < extraPhotosToPreload; i++) {
              // this is quite inefficient... we constantly convert the rather long Set to an array
              const photoName = getRandomItem(Array.from(preloadingCandidates));
              preloadingCandidates.delete(photoName);
              toPreload.push(photoName);
            }

            for (const name of toPreload) {
              preloadImage(name, false);
            }
          }

          const timeElapsed = Date.now() - start;

          const sleepTime = 1000 - timeElapsed;
          if (sleepTime > 0) {
            await sleep(sleepTime);
          }
        }
      }

      init();
    </script>
  </body>
</html>
